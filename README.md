<h1 align="center" >  Blur-O-Matic  <br> [ ᴀɴᴅʀᴏɪᴅ ♾ ᴅᴇᴍᴏ ᴘʀᴏᴊᴇᴄᴛ ]</h1>

## ɪ  ⁃  ᴘʀᴏᴊᴇᴄᴛ ɪɴꜰᴏ

Blur-O-Matic, an app that blurs photos and saves the results to a file. Was that the Loch Ness monster or a toy submarine? With Blur-O-Matic, no one will ever know!
<br>

<div align="center">

⁃ ᴄᴏɴᴛᴇɴᴛꜱ ⁃  
[ᴜꜱᴇʀ ꜰᴇᴀᴛᴜʀᴇꜱ](#ɪɪ--ᴡʜᴀᴛ-ᴜꜱᴇʀꜱ-ᴄᴀɴ-ᴇxᴘᴇᴄᴛ)
| [ᴀᴘᴘ ꜱᴄʀᴇᴇɴꜱ](#ɪɪɪ--ᴠɪꜱᴜᴀʟ-ᴛᴏᴜʀ-ᴏꜰ-ᴛʜᴇ-ᴀᴘᴘ-ꜱᴄʀᴇᴇɴꜱ)
| [ᴘʀᴏᴊᴇᴄᴛ ʙʀᴀɴᴄʜᴇꜱ](#ɪᴠ--ᴘʀᴏᴊᴇᴄᴛ-ʙʀᴀɴᴄʜᴇꜱ)
| [ᴅᴇᴠ ꜰᴇᴀᴛᴜʀᴇꜱ](#ᴠ--ʙᴇʜɪɴᴅ-ᴛʜᴇ-ᴄᴏᴅᴇ-ᴅᴇᴠ-ꜰᴇᴀᴛᴜʀᴇꜱ)
| [ᴘʀᴏᴊᴇᴄᴛ ɴᴏᴛᴇꜱ](#ᴠɪ--ᴘʀᴏᴊᴇᴄᴛ-ɴᴏᴛᴇꜱ)

<br>
<br>

[![Platform](https://img.shields.io/badge/-Android%20|%20Platform-2E8B57?logo=android&logoColor=white&style=for-the-badge)](#)
[![Language](https://img.shields.io/badge/-Kotlin%20|%20Language-%2307405e?logo=kotlin&logoColor=white&style=for-the-badge)](#)

[![MIN API LEVEL](https://img.shields.io/badge/-MIN%20SDK%20|%2024-1C1E24?logo=planetscale&logoColor=00C7B7&style=for-the-badge)](#)
[![Target Version](https://img.shields.io/badge/-Target%20SDK%20|%2034-1C1E24?logo=planetscale&logoColor=00C7B7&style=for-the-badge)](#)
[![Architecture](https://img.shields.io/badge/-Architecture%20|%20MVI-1C1E24?logo=planetscale&logoColor=00C7B7&style=for-the-badge)](#)
[![UI](https://img.shields.io/badge/-UI%20|%20Jetpack%20Compose-1C1E24?logo=planetscale&logoColor=00C7B7&style=for-the-badge)](#)

<br>
<br>
<img
    src="./screenshots/alpha_main.png"
    width="340" height="720" 
/>

<br>

</div>

## ɪɪ ⁃ ᴡʜᴀᴛ ᴜꜱᴇʀꜱ ᴄᴀɴ ᴇxᴘᴇᴄᴛ

### ⭓ Features


1. **Blur Intensity Adjustment:** Users can customize the intensity of the blur effect, allowing for light blurring to complete obscurity.


2.  **Offline Functionality:** Users can blur images without needing an internet connection.


3.  **User-Friendly Interface:** A simple and intuitive interface that makes it easy for users to navigate and use the app's features.


##
### ⭓ Requirements
- Android 7.0 and Above
- Min SDK version 24


##
### ⭓ Permissions
- N/A

<hr>

## ɪɪɪ ⁃ ᴠɪꜱᴜᴀʟ ᴛᴏᴜʀ ᴏꜰ ᴛʜᴇ ᴀᴘᴘ: ꜱᴄʀᴇᴇɴꜱ

<p align="center">
<img 
  src="./screenshots/alpha_main.png" 
   width="200" height="460" 
  />
<img 
  src="./screenshots/screen_see_file.png" 
  width="200" height="460" 
  />
</p>



#
<div align="center">


![forthebadge](https://forthebadge.com/images/badges/built-with-love.svg)
![ForTheBadge ANDROID](https://forthebadge.com/images/badges/built-for-android.svg)
![ForTheBadge GIT](https://forthebadge.com/images/badges/uses-git.svg)

  <br>

<kbd>[&nbsp; ⮝ &nbsp;  BACK TO TOP  &nbsp;&nbsp;&nbsp;](#ɪ----ᴘʀᴏᴊᴇᴄᴛ-ɪɴꜰᴏ) </kbd>
</div>

#
## ɪᴠ ⁃ ᴘʀᴏᴊᴇᴄᴛ ʙʀᴀɴᴄʜᴇꜱ

<!-- Main / Master / Production Branch -->

> <samp> **PRODUCTION BRANCH :**  </samp>  
> Stable code for deployment  
> ➲ [main][branch-main]

> <samp> **STAGING BRANCH :**  </samp>  
> `FLOW | Staging → Production`  
> For pre-release testing, which ensures that the code is stable, bug-free, and ready for deployment.  
> ➲ [staging][branch-staging]

> <samp> **DEVELOPMENT BRANCH :**  </samp>  
> `FLOW | Development → Release → Staging → Production`  
> Active codebase for ongoing development efforts  (New features, bug fixes, and improvements..)  
> ➲ [development][branch-development]



> <samp> **FEATURE BRANCHES :** N/A  </samp>  
> `FLOW | Feature → Development → Release → Staging → Production`  
<!-- 
> <samp> **FEATURE BRANCHES :**  </samp>  
> For Isolated feature development (Ensures changes are tested and reviewed before merging into the main workflow)  
>   
> feature/  
> ➲ dark-theme  
> ➲ offline-db-impl
-->


> <samp> **RELEASE BRANCHES :** N/A  </samp>  
> `FLOW | Release → Staging → Production`  
<!-- 
> <samp> **RELEASE BRANCHES :**  </samp>  
> Prepares the code for final testing and deployment in a new version release.
>   
> release/  
> ➲ version-number
-->



> <samp> **HOTFIX BRANCHES :** N/A  </samp>  
> `FLOW | Hotfix → Staging → Production`  
<!-- 
> <samp> **HOTFIX BRANCHES :**  </samp>  
> Handles critical fixes in production that need immediate resolution.
>   
> hotfix/  
> ➲ main-screen-crash 
-->


> <samp> **BUGFIX BRANCHES :** N/A  </samp>  
> `FLOW | Bugfix → Development → Release → Staging → Production` 
<!-- 
> <samp> **BUGFIX BRANCHES :**  </samp>  
> Addresses specific bugs identified during development and testing.
>   
> bugfix/  
> ➲ main-screen-error
-->

<!-- 
> <samp> **EXPERIMENTAL BRANCHES :** N/A  </samp>  

> <samp> **EXPERIMENTAL BRANCHES :**  </samp>  
> Facilitates trial and error to test new ideas and concepts.
>   
> experiment/  
> ➲ main-screen-change-colours
-->
<!-- Experimental → Feature → Development → Release → Staging → Main/Production   -->


[branch-main]:  https://github.com/dizzcode/inventory-android-test-app/tree/main
[branch-development]:  https://github.com/dizzcode/inventory-android-test-app/tree/development
[branch-staging]:  https://github.com/dizzcode/inventory-android-test-app/tree/staging

[branch-feature-NAME]:  https://github.com/dizzcode/inventory-android-test-app/tree/staging

[branch-hotfix-NAME]:  https://github.com/dizzcode/inventory-android-test-app/tree/staging

[branch-bugfix-NAME]:  https://github.com/dizzcode/inventory-android-test-app/tree/staging

<br>  



#
## ᴠ ⁃ ʙᴇʜɪɴᴅ ᴛʜᴇ ᴄᴏᴅᴇ: ᴅᴇᴠ ꜰᴇᴀᴛᴜʀᴇꜱ

### ⭓ App Dependencies/Libraries Overview

<br>

* [Kotlin][0] : Kotlin is statically typed & first-class language for Android Development.
* [Coroutines][1] : For Asynchronus or non-blocking operations.
* [Flows][2] : Data Streaming API which is built on top of Coroutines.
* [Jetpack Compose][3] : Toolkit for building native UI in a declarative way.
* [Room][4] : Save data in a local database using Room
* [Retrofit][5] : Type-safe REST client for Android to consume RESTful web services.
* [Dagger Hilt][6] : Dependency injection library for Android.
* [Kotlin DSL][7] : For writing gradle script for Kotlin is more readable and offers better compile-time.

[0]:  https://kotlinlang.org/
[1]:  https://kotlinlang.org/docs/coroutines-overview.html
[2]:  https://developer.android.com/kotlin/flow
[3]:  https://developer.android.com/jetpack/compose
[4]:  https://developer.android.com/training/data-storage/room
[5]:  https://github.com/square/retrofit
[6]:  https://dagger.dev/hilt/
[7]:  https://docs.gradle.org/current/userguide/kotlin_dsl.html


#
### ⭓ Features

1. Jetpack WorkManager &nbsp;|&nbsp;  [ More-> ](#1-jetpack-workmanager)  
    1.1 What is WorkManager?  
    1.2 When to use WorkManager  
    1.3 Add WorkManager to your app  
    1.4 WorkManager Basics  
    1.5 Create the BlurWorker  
    1.6 Update WorkManagerBluromaticRepository  
    1.7 Input data and output data  
    1.8 Chain your Work  


2. Advanced WorkManager and Testing  &nbsp;|&nbsp;  [ More-> ](#2-advanced-workmanager-and-testing)  
   2.1 Ensure unique work  
    2.2 Tag and update the UI based on Work status  
    2.3 Show final output  
    2.4 Cancel work  
    2.5 Work constraints [Adding Battery Not Low Constraint]  

3. Write tests for Worker implementations  &nbsp;|&nbsp;  [ More-> ](#3-write-tests-for-worker-implementations)

<br>

Structure of the project &nbsp;|&nbsp;  [ More-> ](#structure-of-the-project)

<br>
<br>  
<br>  

#
<div align="center">

<kbd>[&nbsp; ⮝ &nbsp;  BACK TO TOP  &nbsp;&nbsp;&nbsp;](#ɪ----ᴘʀᴏᴊᴇᴄᴛ-ɪɴꜰᴏ) </kbd>
</div>

#
# ᴠɪ ⁃ ᴘʀᴏᴊᴇᴄᴛ ɴᴏᴛᴇꜱ

<br> 

____

## Structure of the project

- WorkerUtils: &nbsp;&nbsp; [ View Class --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/WorkerUtils.kt)
  - Convenience methods which you later use to display Notifications and code to save a bitmap to file.


- BlurViewModel: &nbsp;&nbsp; [ View Class --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BlurViewModel.kt)
  - This view model stores the state of the app and interacts with the repository.


- WorkManagerBluromaticRepository:  &nbsp;&nbsp; [ View Class --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)
  - The class where you start the background work with WorkManager.


- Constants:  &nbsp;&nbsp; [ View Class --> ](./app/src/main/java/dizzcode/com/bluromatic/Constants.kt)
  - A static class with some constants you use during the codelab.


- BluromaticScreen:  &nbsp;&nbsp; [ View Class --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BluromaticScreen.kt)
  - Contains composable functions for the UI and interacts with the BlurViewModel. The composable functions show the image and include radio buttons to select the desired blur level.



____

## 1. Jetpack WorkManager

### 1.1 What is WorkManager?
WorkManager is a part of Android Jetpack and helps manage background tasks. It runs tasks as soon as possible (opportunistic execution) and makes sure they eventually get done, even if you leave the app (guaranteed execution).

WorkManager is an incredibly flexible library that has many additional benefits. Some of these benefits include:

- Support for both asynchronous one-off and periodic tasks.
- Support for constraints, such as network conditions, storage space, and charging status.
- Chaining of complex work requests, such as running work in parallel.
- Output from one work request used as input for the next.
- Handling API-level compatibility back to API level 14 (see note).
- Working with or without Google Play services.
- Following system health best practices.
- Support to easily display state of work requests in the app's UI.

<br>

#
> [!NOTE]
> #
> WorkManager sits on top of a few APIs, such as `JobScheduler` and `AlarmManager`.  
> WorkManager picks the right APIs to use based on conditions like the user's device API level.  
> To learn more, check out [Schedule tasks with WorkManager](https://developer.android.com/topic/libraries/architecture/workmanager/) and the [WorkManager documentation](https://developer.android.com/reference/androidx/work/WorkManager).
> #

<br>

#
### 1.2 When to use WorkManager

Use WorkManager when you need to run tasks that should finish, even if the app is closed or the user goes to the home screen. It's great for background tasks that don't depend on the app staying open.

Some examples of tasks that are a good use of WorkManager:

- Periodically querying for latest news stories.
- Applying filters to an image and then saving the image.
- Periodically syncing local data with the network.

<br>

#
> [!NOTE]
> #
> WorkManager is one option for running a task off of the main thread  
> but it is not a catch-all for running every type of task off of the main thread.  
> Coroutines are another option.
> #

<br>

#
### 1.3 Add WorkManager to your app

Set up dependencies | inside `build.gradle.kts` (Module :app)

```kotlin
// WorkManager
implementation("androidx.work:work-runtime-ktx:2.8.1")
```

<br>  


#
### 1.4 WorkManager Basics

Here are the basic WorkManager classes you should know:

1. Worker / CoroutineWorker:

   - The Worker class runs work on a background thread synchronously.
   - For asynchronous work (like using Kotlin Coroutines), you use CoroutineWorker.
   - You create your own worker class by extending `CoroutineWorker` and overriding the `doWork() `method, where you write the code for the task to run in the background.

    
2. WorkRequest:

   - This class is used to request background tasks.
   - You can define whether the work runs once or periodically.
   - You can also set constraints, like waiting for the device to charge before starting the task.
   - You include your CoroutineWorker when creating a WorkRequest.


3. WorkManager:

   - This class schedules your WorkRequest and makes sure it runs.
   - It balances system resources while respecting any constraints you set.

In this app, you'll create a BlurWorker class to handle blurring an image. When the user clicks the Start button, WorkManager will enqueue and run the WorkRequest for the blurring task.

<br>

#
### 1.5 Create the BlurWorker

To create a BlurWorker class that extends CoroutineWorker and processes an image in the background, follow these steps:

- Right-click on the package `workers` in your Android project. **Select New -> Kotlin Class/File**
- Name the new Kotlin class BlurWorker.
- Extend BlurWorker from CoroutineWorker and pass the required constructor parameters.

```kotlin
import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters

class BlurWorker(
    ctx: Context,
    params: WorkerParameters
) : CoroutineWorker(ctx, params) {

}
```

The BlurWorker class uses CoroutineWorker instead of Worker. This is because CoroutineWorker has a doWork() function that can run tasks asynchronously, which Worker cannot do. For Kotlin users, CoroutineWorker is the best choice for background tasks.

To implement the doWork() method

- Place your cursor inside the BlurWorker class.
- From the Android Studio menu, select `Code > Override Methods....`
- In the Override Members popup, choose doWork(), and click OK.

<br>  

Before the class declaration, create a variable called TAG and set it to "BlurWorker". This variable isn't directly used in the doWork() method, but you'll use it later for logging with Log().

```kotlin
import ...

private const val TAG = "BlurWorker"

class BlurWorker(
// ...
```

#

- To see when the work runs, use the `makeStatusNotification()` function from WorkerUtil.  
- This function shows a notification banner at the top of the screen. 
- In the `doWork()` method, call makeStatusNotification() to let the user know that the blur worker has started and is blurring the image.
- Add a return `try...catch` code block, which is where the actual blur image work is performed.
- In the try block, add a call to Result.success().
- In the catch block, add a call to Result.failure().

```kotlin
    override suspend fun doWork(): Result {
        
    makeStatusNotification(
        applicationContext.resources.getString(R.string.blurring_image),
        applicationContext
    )
    return try {
        Result.success()
    } catch (throwable: Throwable) {
        Result.failure()
    }
    
}
```

#
> [!NOTE]
> #
> WorkManager uses Result.success()   
> and Result.failure() to indicate the final status of the work request being performed.
> #

#

> Result.success()

- In the try block of the doWork() method, you can create a new variable named picture and use BitmapFactory.decodeResource() to load the cupcake image. Here’s how to do it:
- Blur the bitmap by calling the blurBitmap() function and pass in the picture variable and a value of 1 (one) for the blurLevel parameter.
- Save the result in a new variable named output.
- Create a new variable outputUri and populate it with a call to the writeBitmapToFile() function.
- In the call to writeBitmapToFile(), pass the application context and the output variable as arguments.
- Add code to display a notification message to the user that contains the outputUri variable.

```kotlin

    // ...
    return try {
        val picture = BitmapFactory.decodeResource(
            applicationContext.resources,
            R.drawable.android_cupcake
        )

        val output = blurBitmap(picture, 1)

        // Write bitmap to a temp file
        val outputUri = writeBitmapToFile(applicationContext, output)

        makeStatusNotification(
            "Output is $outputUri",
            applicationContext
        )

        Result.success()

    }    // ...

```

#
> Result.failure()

In the catch block, log an error message to indicate an error occurred while attempting to blur the image. The call to Log.e() passes the previously defined TAG variable, an appropriate message, and the exception being thrown.

```kotlin
//...
 catch (throwable: Throwable) {
    Log.e(
        TAG,
        applicationContext.resources.getString(R.string.error_applying_blur),
        throwable
    )
    Result.failure()
}
//...
```

#

A CoroutineWorker usually runs with Dispatchers.Default, but you can change it by using withContext() with a different dispatcher.

- Create a withContext() block.
- Inside it, use Dispatchers.IO so the code runs in a thread pool for blocking I/O tasks.
- Move the existing try...catch code into this block.

In Android Studio, you may see an error because you can't use return directly in a lambda function. To fix this, you should add a label like this:

- Change return try { to return@withContext try {.  
 

Since this worker runs quickly, you should also add a delay to simulate slower work:

- Inside the withContext() lambda, call the delay() function.
- Pass in the DELAY_TIME_MILLIS constant to create a delay between notification messages.  


This delay is just for the codelab to help show the notifications clearly.

```kotlin
//...
return withContext(Dispatchers.IO) {

    // This is an utility function added to emulate slower work.
    delay(DELAY_TIME_MILLIS)

    //return try {
    return@withContext try {
        // ...
    } catch (throwable: Throwable) {
        // ...
    }
}
//...
```

<br>

#
### 1.6 Update WorkManagerBluromaticRepository

In the data/WorkManagerBluromaticRepository.kt file, you can set up the WorkManagerBluromaticRepository class to handle interactions with the WorkManager. Here’s how to create a private variable named workManager and store a WorkManager instance in it:

- Inside the WorkManagerBluromaticRepository class, declare the private variable.
- Use WorkManager.getInstance(context) to initialize it.

```kotlin
//...
class WorkManagerBluromaticRepository(context: Context) : BluromaticRepository {

    // New code
    private val workManager = WorkManager.getInstance(context)
//...
```


#### Create and enqueue the WorkRequest in WorkManager

Now it’s time to create a WorkRequest and tell WorkManager to run it! There are two types of WorkRequests:

- `OneTimeWorkRequest`: This runs only once.
- `PeriodicWorkRequest`: This runs repeatedly on a schedule.  

Since you only want to blur the image once when the Start button is clicked, you’ll handle this in the applyBlur() method.

- In the applyBlur() method, follow these steps:

- Create a new variable named blurBuilder.  

Use OneTimeWorkRequestBuilder from WorkManager KTX to create a OneTimeWorkRequest for the blur worker.

- Start the work by calling the enqueue() method on your workManager object.

```kotlin
//...
override fun applyBlur(blurLevel: Int) {
    // Create WorkRequest to blur the image
    val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()

    // Start the work
    workManager.enqueue(blurBuilder.build())
}
//...
```

Run the app and click the Start button to see the notification. Right now, the image will blur the same amount no matter which option you choose. In later steps, the blur amount will change based on your selection.


#
> [!NOTE]
> #
> The app requires notifications to be enabled.  
> If a notification is not shown, navigate to Settings > Apps > Blur-O-Matic > Notifications and enable All Blur-O-Matic notifications.
> #


- To confirm that the image successfully blurs, you can open the Device Explorer in Android Studio:

- Then navigate to data > data > PACKAGE_NAME > files > blur_filter_outputs > <URI> and confirm that the cupcake image is in fact blurred:


<p align="center">
<img 
  src="./screenshots/device_explorer.png" 
   width="280" height="440" 
  />
<img 
  src="./screenshots/device_explorer_img.png" 
  width="520" height="240" 
  />
</p>


<br>

#
### 1.7 Input data and output data

Input and output in a worker are handled using Data objects, which store small key/value pairs. These are used to pass information into and out of a worker from the WorkRequest.

Next, you will pass the image URI to the BlurWorker by creating an input Data object.

#### Create input data object

In WorkManagerBluromaticRepository.kt, add a private imageUri variable and set it by calling context.getImageUri().

```kotlin
//...
class WorkManagerBluromaticRepository(context: Context) : BluromaticRepository {

    private var imageUri: Uri = context.getImageUri() // <- Add this
    private val workManager = WorkManager.getInstance(context)
//...
```

<br>

The app code contains the createInputDataForWorkRequest() helper function for creating input data objects.

```kotlin
//...
class WorkManagerBluromaticRepository(context: Context) : BluromaticRepository {
    //...
    private fun createInputDataForWorkRequest(blurLevel: Int, imageUri: Uri): Data {
        val builder = Data.Builder()
        builder.putString(KEY_IMAGE_URI, imageUri.toString()).putInt(BLUR_LEVEL, blurLevel)
        return builder.build()
    }
//...
```
<br>

First, a helper function creates a Data.Builder object, adds the imageUri and blurLevel as key/value pairs, and returns the Data object using builder.build().

To set the input data for the WorkRequest, call blurBuilder.setInputData(). Pass the Data object created in one step by using the createInputDataForWorkRequest() function, passing in the blurLevel and imageUri variables.

```kotlin
//...
override fun applyBlur(blurLevel: Int) {
    // Create WorkRequest to blur the image
    val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()

    // New code for input data object
    blurBuilder.setInputData(createInputDataForWorkRequest(blurLevel, imageUri))

    workManager.enqueue(blurBuilder.build())
}
//...
```

[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)

<br>

#### Access the input data object

In the doWork() method:

- Create resourceUri with inputData.getString(KEY_IMAGE_URI).
- Create blurLevel with inputData.getInt(BLUR_LEVEL, 1) to default to 1 if not provided.

```kotlin
//...
override fun doWork(): Result {

    // ADD THESE LINES
    val resourceUri = inputData.getString(KEY_IMAGE_URI)
    val blurLevel = inputData.getInt(KEY_BLUR_LEVEL, 1)

    // ... rest of doWork()
}
//...
```

[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/BlurWorker.kt)

<br> 

- Check if resourceUri is populated; if not, throw an exception using require().
- Add a contentResolver object using applicationContext.
- Use BitmapFactory.decodeStream() to create the Bitmap from the URI.
- Pass the blurLevel variable to the blurBitmap() function.

```kotlin
//...
            return@withContext try {

                require(!resourceUri.isNullOrBlank()) {
                    val errorMessage =
                        applicationContext.resources.getString(R.string.invalid_input_uri)
                    Log.e(TAG, errorMessage)
                    errorMessage
                }
                val resolver = applicationContext.contentResolver

                val picture = BitmapFactory.decodeStream(
                    resolver.openInputStream(Uri.parse(resourceUri))
                )

//                val picture = BitmapFactory.decodeResource(
//                    applicationContext.resources,
//                    R.drawable.android_cupcake
//                )

                val output = blurBitmap(picture, blurLevel)
//...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/BlurWorker.kt)

<br>

#### Create the output data object

You’re almost finished with the Worker! To return the output URI as an output data object, follow these steps:

- Before Result.success(), create a variable named outputData.
- Use the workDataOf() function to populate outputData with KEY_IMAGE_URI as the key and outputUri as the value. This creates a Data object from the key/value pair.
This way, the output URI will be easily accessible for other workers in the chain.

- Update the Result.success() code to take this new Data object as an argument.

- Remove the code that displays the notification as it is no longer needed because the output Data object now uses the URI.

```kotlin
//...
val outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())
    //...

// REMOVE the following notification code
//makeStatusNotification(
//    "Output is $outputUri",
//    applicationContext
//)

//Result.success()
Result.success(outputData)
//...
```

<br>

> Full Code
```kotlin
//...
return@withContext try {

    require(!resourceUri.isNullOrBlank()) {
        val errorMessage =
            applicationContext.resources.getString(R.string.invalid_input_uri)
        Log.e(TAG, errorMessage)
        errorMessage
    }
    val resolver = applicationContext.contentResolver

    val picture = BitmapFactory.decodeStream(
        resolver.openInputStream(Uri.parse(resourceUri))
    )

    val output = blurBitmap(picture, blurLevel)

    // Write bitmap to a temp file
    val outputUri = writeBitmapToFile(applicationContext, output)

    val outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())

    Result.success(outputData)

}
//...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/BlurWorker.kt)



<br>

#
### 1.8 Chain your Work

- The app currently only blurs the image.
- Missing functionalities include:
  - No cleanup of temporary files.
  - No saving of the image to a permanent file.
  - Same blur amount applied each time.
- Use a WorkManager chain to enhance functionality.
- Create separate WorkerRequests to run tasks in order or in parallel.

#### Create CleanupWorker

The CleanupWorker is responsible for deleting temporary files if they exist. To set this up:

- Right-click on the package com.example.bluromatic.workers in your Android project.
- Select New -> Kotlin Class/File.
- Name the new class CleanupWorker.
- Copy the provided code for CleanupWorker.kt into the new class.

You can use the given code as is.

> Full Code
```kotlin

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dizzcode.com.bluromatic.DELAY_TIME_MILLIS
import dizzcode.com.bluromatic.OUTPUT_PATH
import dizzcode.com.bluromatic.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.io.File

/**
 * Cleans up temporary files generated during blurring process
 */
private const val TAG = "CleanupWorker"

class CleanupWorker(
    ctx: Context,
    params: WorkerParameters
) : CoroutineWorker(ctx, params) {

    override suspend fun doWork(): Result {
        /** Makes a notification when the work starts and slows down the work so that it's easier
         * to see each WorkRequest start, even on emulated devices
         */
        makeStatusNotification(
            applicationContext.resources.getString(R.string.cleaning_up_files),
            applicationContext
        )

        return withContext(Dispatchers.IO) {
            delay(DELAY_TIME_MILLIS)

            return@withContext try {
                val outputDirectory = File(applicationContext.filesDir, OUTPUT_PATH)
                if (outputDirectory.exists()) {
                    val entries = outputDirectory.listFiles()
                    if (entries != null) {
                        for (entry in entries) {
                            val name = entry.name
                            if (name.isNotEmpty() && name.endsWith(".png")) {
                                val deleted = entry.delete()
                                Log.i(TAG, "Deleted $name - $deleted")
                            }
                        }
                    }
                }
                Result.success()
            } catch (exception: Exception) {
                Log.e(
                    TAG,
                    applicationContext.resources.getString(R.string.error_cleaning_file),
                    exception
                )
                Result.failure()
            }
        }
    }
}
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/CleanupWorker.kt)

<br>

#### Create SaveImageToFileWorker

The SaveImageToFileWorker saves a temporary file to a permanent one:

- Input: Temporary blurred image URI (key: KEY_IMAGE_URI).
- Output: Saved blurred image URI (key: KEY_IMAGE_URI).

To create this worker:

- Right-click on com.example.bluromatic.workers and select New -> Kotlin Class/File.
- Name it SaveImageToFileWorker.
- Copy the provided code.

File handling is similar to earlier input/output handling with KEY_IMAGE_URI.


> Full Code
```kotlin

import android.content.Context
import android.graphics.BitmapFactory
import android.net.Uri
import android.provider.MediaStore
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import androidx.work.workDataOf
import dizzcode.com.bluromatic.DELAY_TIME_MILLIS
import dizzcode.com.bluromatic.KEY_IMAGE_URI
import dizzcode.com.bluromatic.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.Date

/**
 * Saves the image to a permanent file
 */
private const val TAG = "SaveImageToFileWorker"

class SaveImageToFileWorker(
    ctx: Context,
    params: WorkerParameters
) : CoroutineWorker(ctx, params) {

    private val title = "Blurred Image"
    private val dateFormatter = SimpleDateFormat(
        "yyyy.MM.dd 'at' HH:mm:ss z",
        Locale.getDefault()
    )

    override suspend fun doWork(): Result {
        // Makes a notification when the work starts and slows down the work so that
        // it's easier to see each WorkRequest start, even on emulated devices
        makeStatusNotification(
            applicationContext.resources.getString(R.string.saving_image),
            applicationContext
        )

        return withContext(Dispatchers.IO) {
            delay(DELAY_TIME_MILLIS)

            val resolver = applicationContext.contentResolver
            return@withContext try {
                val resourceUri = inputData.getString(KEY_IMAGE_URI)
                val bitmap = BitmapFactory.decodeStream(
                    resolver.openInputStream(Uri.parse(resourceUri))
                )
                val imageUrl = MediaStore.Images.Media.insertImage(
                    resolver, bitmap, title, dateFormatter.format(Date())
                )
                if (!imageUrl.isNullOrEmpty()) {
                    val output = workDataOf(KEY_IMAGE_URI to imageUrl)

                    Result.success(output)
                } else {
                    Log.e(
                        TAG,
                        applicationContext.resources.getString(R.string.writing_to_mediaStore_failed)
                    )
                    Result.failure()
                }
            } catch (exception: Exception) {
                Log.e(
                    TAG,
                    applicationContext.resources.getString(R.string.error_saving_image),
                    exception
                )
                Result.failure()
            }
        }
    }
}

```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/workers/SaveImageToFileWorker.kt)

<br>

#
> [!NOTE]
> #
> The provided code for the CleanupWorker worker and the SaveImageToFileWorker worker each include the statement 
> delay(DELAY_TIME_MILLIS).   
> This code slows the worker down while it is running. 
> This code was included for instructional purposes so you can more easily see the workers running in the Background Task Inspector and to also provide a brief pause between notification messages.  
> You do not normally use this code in production code.
> #


<br>

#### Create a chain of work

Currently, the code only runs a single WorkRequest. To create a chain of WorkRequests:

- Use workManager.beginWith() instead of OneTimeWorkRequestBuilder.
- The first WorkRequest will clean up temporary files.
- beginWith() returns a WorkContinuation object to start the chain.
This allows for sequential execution of tasks.

<br>

To extend the chain of work requests:

- Remove the call to workManager.enqueue(blurBuilder.build()), as it only enqueues a single work request.
- Add the next work request to the chain by calling the .then() method and passing in the desired WorkRequest object.
This way, you can create a sequence of work tasks to be executed one after the other.

Create a work request to save the image and add it to the chain.

To start the work, call the enqueue() method on the continuation object.

This code produces and runs the following chain of WorkRequests: a CleanupWorker WorkRequest followed by a BlurWorker WorkRequest followed by a SaveImageToFileWorker WorkRequest.



```kotlin
// ...
override fun applyBlur(blurLevel: Int) {
    // Add WorkRequest to Cleanup temporary images
    var continuation = workManager.beginWith(OneTimeWorkRequest.from(CleanupWorker::class.java))

    // Create WorkRequest to blur the image
    val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()

    blurBuilder.setInputData(createInputDataForWorkRequest(blurLevel, imageUri))

    //workManager.enqueue(blurBuilder.build())

    // Add the blur work request to the chain
    continuation = continuation.then(blurBuilder.build())

    // Add WorkRequest to save the image to the filesystem
    val save = OneTimeWorkRequestBuilder<SaveImageToFileWorker>()
        .build()
    continuation = continuation.then(save)

    // Start the work
    continuation.enqueue()
}
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)


#
> [!NOTE]
> #
> In this code, there’s an alternate way to create a OneTimeWorkRequest object.
> You can call OneTimeWorkRequest.from(CleanupWorker::class.java), which is equivalent to OneTimeWorkRequestBuilder<CleanupWorker>().build().
> OneTimeWorkRequest comes from the AndroidX Work library, while OneTimeWorkRequestBuilder is a helper function provided by the WorkManager KTX extension.
> #

<br>

#

<kbd>[&nbsp; ► &nbsp;  BACK TO Project Notes  &nbsp;&nbsp;&nbsp;](#ᴠɪ--ᴘʀᴏᴊᴇᴄᴛ-ɴᴏᴛᴇꜱ) </kbd>

____

<br>

<br>

<br>


## 2. Advanced WorkManager and Testing

### 2.1 Ensure unique work

it's time to tackle another powerful feature of WorkManager: unique work sequences.

- WorkManager allows for unique work sequences, ensuring only one chain runs at a time.
- Use beginUniqueWork() instead of beginWith() to create a unique work chain.
- Provide a unique String name to identify the entire chain for querying.
- Pass an ExistingWorkPolicy object to define behavior for existing work:
- Possible values: REPLACE, KEEP, APPEND, APPEND_OR_REPLACE.
- Use REPLACE policy to stop the current work if a user starts a new blur task.
- Ensure that clicking Start while a work request is enqueued replaces the previous request.



In data/WorkManagerBluromaticRepository.kt, inside applyBlur():  

- Remove the call to beginWith().
- Add a call to beginUniqueWork().
- Pass IMAGE_MANIPULATION_WORK_NAME as the first parameter.
- Use ExistingWorkPolicy.REPLACE as the second parameter.
- Create a new OneTimeWorkRequest for CleanupWorker as the third parameter.


```kotlin
// ...
// REPLACE THIS CODE:
// var continuation = workManager.beginWith(OneTimeWorkRequest.from(CleanupWorker::class.java))
// WITH
var continuation = workManager
    .beginUniqueWork(
        IMAGE_MANIPULATION_WORK_NAME,
        ExistingWorkPolicy.REPLACE,
        OneTimeWorkRequest.from(CleanupWorker::class.java)
    )
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)

<br>

#
### 2.2 Tag and update the UI based on Work status

Updating UI Based on Work Status
- Update UI based on enqueued work information.

<br>

Methods to Get Work Information:

1. Get work using ID:
   - Method: getWorkInfoByIdLiveData()
   - Description: Returns LiveData<WorkInfo> for a specific WorkRequest by its ID.
2. Get work using unique chain name:
   - Method: getWorkInfosForUniqueWorkLiveData()
   - Description: Returns LiveData<List<WorkInfo>> for all work in a unique chain of WorkRequests.
3. Get work using a tag:
   - Method: getWorkInfosByTagLiveData()
   - Description: Returns LiveData<List<WorkInfo>> for a specific tag.


**Note:**  
WorkManager APIs are exposed as LiveData but are converted to Flow for flexibility in future updates.

WorkInfo Object Details:

- Contains current state: BLOCKED, CANCELLED, ENQUEUED, FAILED, RUNNING, or SUCCEEDED.
- Includes output data if WorkRequest is finished.
- LiveData: A lifecycle-aware observable data holder converted to Flow using .asFlow().

<br>

Tagging WorkRequest:
- Add a tag to SaveImageToFileWorker to retrieve its WorkInfo via getWorkInfosByTagLiveData().
- Alternative: Use getWorkInfosForUniqueWorkLiveData() to access information about all related WorkRequests (CleanupWorker, BlurWorker, SaveImageToFileWorker), but requires extra code to isolate SaveImageToFileWorker information.

<br>

### Tag the work request

Tagging Work in WorkManagerBluromaticRepository.kt
- Location: Inside the applyBlur() function.
- Task: Tag the SaveImageToFileWorker work request.
- Implementation:
  - Call the addTag() method when creating the work request.
  - Pass in: The String constant TAG_OUTPUT as the tag.

```kotlin
import com.example.bluromatic.TAG_OUTPUT
...
val save = OneTimeWorkRequestBuilder<SaveImageToFileWorker>()
    .addTag(TAG_OUTPUT) // <- Add this
    .build()
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)

<br>

#
### Get the WorkInfo

Using WorkInfo in UI Logic
- Purpose: Determine which composables to display based on BlurUiState using WorkInfo from SaveImageToFileWorker.
- Data Flow: The ViewModel consumes data from the repository’s outputWorkInfo variable.

Steps to Retrieve WorkInfo

- File: In data/WorkManagerBluromaticRepository.kt.
- Method Call:
  - Use workManager.getWorkInfosByTagLiveData() to populate outputWorkInfo.
  - Returns: LiveData, a lifecycle-aware observable data holder.
- Convert to Flow:
  - Chain .asFlow() to convert the method to a Flow for compatibility with Kotlin.
- Transform Flow:
  - Chain .mapNotNull() to ensure the Flow contains values.
  - Transform Rule: Select the first item if not empty; otherwise, return null, which gets removed.
- Type Adjustments:
  - Remove the ? from the Flow type since .mapNotNull() guarantees a value.
  - Update the BluromaticRepository interface by removing the ?.

Emission: WorkInfo information is emitted as a Flow from the repository, which the ViewModel consumes.

> Initial Code

```kotlin
// ...
override val outputWorkInfo: Flow<WorkInfo?> = MutableStateFlow(null)
// ...
```
#

> Modified Code

```kotlin
// ...
override val outputWorkInfo: Flow<WorkInfo> =
    workManager.getWorkInfosByTagLiveData(TAG_OUTPUT).asFlow().mapNotNull {
        if (it.isNotEmpty()) it.first() else null
    }
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)

```kotlin
// ...
interface BluromaticRepository {
    //    val outputWorkInfo: Flow<WorkInfo?>
    val outputWorkInfo: Flow<WorkInfo>
// ...
```

<br>

#
### Update the BlurUiState

Purpose: Use WorkInfo emitted by the repository’s outputWorkInfo Flow to update the blurUiState variable, which controls which composables to display in the UI.


**Steps to Update blurUiState**  
1. Populate blurUiState:
    - Use the outputWorkInfo Flow from the repository.
   
2. Map Flow to BlurUiState:
   - When work is finished: Set blurUiState to BlurUiState.Complete(outputUri = "").
   - When work is cancelled: Set blurUiState to BlurUiState.Default.
   - Otherwise: Set blurUiState to BlurUiState.Loading.

3. Convert to StateFlow:
   - Chain .stateIn() to convert Flow to StateFlow.

4. Arguments for .stateIn():
   - First parameter: viewModelScope (ViewModel’s coroutine scope).
   - Second parameter: SharingStarted.WhileSubscribed(5_000) to control sharing behavior.
   - Third parameter: BlurUiState.Default as the initial state.

Result: The ViewModel exposes the UI state as a StateFlow through blurUiState, transforming the Flow from cold to hot with the stateIn() function.

```kotlin
// ...
// REMOVE
// val blurUiState: StateFlow<BlurUiState> = MutableStateFlow(BlurUiState.Default)

// ADD
val blurUiState: StateFlow<BlurUiState> = bluromaticRepository.outputWorkInfo
    .map { info ->
        when {
            info.state.isFinished -> {
                BlurUiState.Complete(outputUri = "")
            }

            info.state == WorkInfo.State.CANCELLED -> {
                BlurUiState.Default
            }

            else -> BlurUiState.Loading
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5_000),
        initialValue = BlurUiState.Default
    )
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BlurViewModel.kt)

<br>

#
### Updating the UI in BluromaticScreen.kt

1. Get UI State:
    - Use blurUiState from the ViewModel to control the UI.

2. Remove Old Button Code:
   - In the Row composable inside BlurActions, remove the Button(onStartClick) code.

3. Add when Block:  
   - Replace the button with a when block using blurUiState as the argument.

4. Default State (BlurUiState.Default):

    - Display the Start button.
    - Set onClick to onStartClick.
    - Set stringResourceId to R.string.start.

5. Loading State (BlurUiState.Loading):  

   - Display the Cancel Work button and a circular progress indicator.
   - Set onClick to onCancelClick.
   - Set stringResourceId to R.string.cancel_work.

6. Complete State (BlurUiState.Complete):

    - Display the Start button again after the image is blurred and saved.
    - Set onClick to onStartClick.
    - Set stringResourceId to R.string.start.

Note:  
The Cancel Work button is included but not used yet. It will be configured in later steps.

```kotlin
@Composable
private fun BlurActions(
// ...
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.Center
    ) {
        // REMOVE
        // Button(
        //     onClick = onStartClick,
        //     modifier = Modifier.fillMaxWidth()
        // ) {
        //     Text(stringResource(R.string.start))
        // }
        // ADD
        when (blurUiState) {
            is BlurUiState.Default -> {
                Button(onStartClick) { Text(stringResource(R.string.start)) }
            }
            is BlurUiState.Loading -> {
                FilledTonalButton(onCancelClick) { Text(stringResource(R.string.cancel_work)) }
                CircularProgressIndicator(modifier = Modifier.padding(dimensionResource(R.dimen.padding_small)))
            }
            is BlurUiState.Complete -> {
                Button(onStartClick) { Text(stringResource(R.string.start)) }
                Spacer(modifier = Modifier.width(dimensionResource(R.dimen.padding_small)))
                FilledTonalButton({ onSeeFileClick(blurUiState.outputUri) })
                { Text(stringResource(R.string.see_file)) }
            }
        }
    }
}
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BluromaticScreen.kt)

<p align="center">
<img 
  src="./screenshots/background_task_inspector.png" 
   width="620" height="180" 
  />
</p>


<br>

#
### 2.3 Show final output

#### Steps to Create the **See File** Button:

1. **Condition:** The "See File" button only appears when the `BlurUiState` is `Complete`.

2. **File:** Open `ui/BluromaticScreen.kt` and navigate to the `BlurActions` composable.

3. **Add Space Between Buttons:**
    - Inside the `BlurUiState.Complete` block, add a `Spacer` composable to create space between the **Start** button and the **See File** button.

4. **Create `FilledTonalButton`:**
    - Add a new `FilledTonalButton` composable in the `BlurUiState.Complete` block.
    - **onClick Parameter:** Pass `onSeeFileClick(blurUiState.outputUri)`.

5. **Add Button Text:**
    - Add a `Text` composable inside the button.
    - **Text Parameter:** Use the string resource ID `R.string.see_file`.

#

### Updating `blurUiState` in ViewModel

1. **State Control:** `BlurUiState` is controlled by the ViewModel, depending on the work request state and the `bluromaticRepository.outputWorkInfo` variable.

2. **File:** In `ui/BlurViewModel.kt`, inside the `map()` transform, follow these steps:

3. **Create Variable `outputImageUri`:**
    - Extract the saved image’s URI from the `outputData` object using the `KEY_IMAGE_URI` key.

4. **Check for a Valid URI:**
    - Use `outputImageUri.isNullOrEmpty()` to check if the URI is populated.

5. **Update `isFinished` Branch:**
    - Modify the `isFinished` condition to also verify that the `outputImageUri` is populated.
    - If true, pass `outputImageUri` to the `BlurUiState.Complete` data object, indicating that a blurred image is available for display.

```kotlin
// ...
val blurUiState: StateFlow<BlurUiState> = bluromaticRepository.outputWorkInfo
    .map { info ->
        //ADD
        val outputImageUri = info.outputData.getString(KEY_IMAGE_URI)

        when {
//                REMOVE
//                info.state.isFinished -> {
//                    BlurUiState.Complete(outputUri = "")
//                }
//                ADD
            info.state.isFinished && !outputImageUri.isNullOrEmpty() -> {
                BlurUiState.Complete(outputUri = outputImageUri)
            }

// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BlurViewModel.kt)


#

### Creating the "See File" Click Event

1. **Objective:** When the user clicks the **See File** button, its `onClick` handler calls a function to display the saved image using its URI.

2. **File:** Open `ui/BluromaticScreen.kt`.

3. **Create `onSeeFileClick` Lambda:**
    - In the `BluromaticScreenContent()` function, within the call to the `BlurActions()` composable, start creating a lambda function for the `onSeeFileClick` parameter.
    - The lambda function should take a single parameter named `currentUri` (this stores the saved image's URI).

4. **Call `showBlurredImage()`:**
    - Inside the body of the lambda function, call the `showBlurredImage()` helper function.
    - **First Parameter:** Pass the `context` variable.
    - **Second Parameter:** Pass the `currentUri` variable.

### Example (Code Explanation):

- **Purpose of `showBlurredImage()`:** The helper function creates an intent and uses it to start a new activity that shows the saved image.


```kotlin
//      REMOVE
//        BlurActions(
//            blurUiState = blurUiState,
//            onStartClick = { applyBlur(selectedValue) },
//            onSeeFileClick = {},
//            onCancelClick = { cancelWork() },
//            modifier = Modifier.fillMaxWidth()
//        )
//      ADD

BlurActions(
    blurUiState = blurUiState,
    onStartClick = { applyBlur(selectedValue) },
    // New lambda code runs when See File button is clicked
    onSeeFileClick = { currentUri ->
        showBlurredImage(context, currentUri)
    },
    onCancelClick = { cancelWork() },
    modifier = Modifier.fillMaxWidth()
)
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BluromaticScreen.kt)


<br>

#
### 2.4  Cancel work

#### Implementing the "Cancel Work" Feature

#### Steps to Cancel Work by Name:

1. **Objective:** Use the **Cancel Work** button to cancel all work in the unique chain of image manipulation tasks.

2. **File:** Open `data/WorkManagerBluromaticRepository.kt`.

3. **Update `cancelWork()` Function:**
    - In the `cancelWork()` function, call `workManager.cancelUniqueWork()`.
    - **Parameter:** Pass the unique chain name `IMAGE_MANIPULATION_WORK_NAME` to ensure the call cancels only the scheduled work in that chain.

#### Example (Explanation):

- **Purpose:** This cancels all the work in the chain, not just a particular step, ensuring that the entire image manipulation process is stopped.


```kotlin
// ...
override fun cancelWork() {
    workManager.cancelUniqueWork(IMAGE_MANIPULATION_WORK_NAME)
}
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)


#

### Implementing `cancelWork()` in the ViewModel

#### Separation of Concerns:

- **Design Principle:** Composable functions should not directly interact with the repository. Instead, composable functions communicate with the ViewModel, and the ViewModel interacts with the repository.
- **Benefit:** Changes to the repository do not affect composable functions, keeping the code modular and easier to maintain.

---

#### Steps to Implement `cancelWork()` in ViewModel:

1. **File:** Open `ui/BlurViewModel.kt`.

2. **Create `cancelWork()` Function:**
    - In the ViewModel, create a new function called `cancelWork()`.

3. **Call Repository Method:**
    - Inside the `cancelWork()` function, on the `bluromaticRepository` object, call the `cancelWork()` method.

#### Example (Explanation):

- **Purpose:** The ViewModel manages the interaction with the repository, allowing composable functions to simply call `cancelWork()` in the ViewModel without worrying about repository logic.

```kotlin
/**
 * Call method from repository to cancel any ongoing WorkRequest
 * */
fun cancelWork() {
    bluromaticRepository.cancelWork()
}
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BlurViewModel.kt)

#

### Setting Up the "Cancel Work" Click Event

#### Steps to Implement Cancel Work Click Event:

1. **File:** Open `ui/BluromaticScreen.kt`.

2. **Navigate to `BluromaticScreen()` Composable:**
    - Locate the `BluromaticScreen()` composable function.

3. **Assign `cancelWork()` to Button Click:**
    - Inside the call to the `BluromaticScreenContent` composable, assign the `cancelWork` parameter to the ViewModel’s `cancelWork()` method.

4. **Assignment:**
    - Set the value of the `cancelWork` parameter to `blurViewModel::cancelWork`.

#### Example (Explanation):

- **Purpose:** When a user clicks the **Cancel Work** button, the ViewModel’s `cancelWork()` method is triggered, ensuring the repository handles the cancellation process through the ViewModel.


```kotlin
fun BluromaticScreen(blurViewModel: BlurViewModel = viewModel(factory = BlurViewModel.Factory)) {
    // ...
        BluromaticScreenContent(
            blurUiState = uiState,
            blurAmountOptions = blurViewModel.blurAmount,
            applyBlur = blurViewModel::applyBlur,
            cancelWork = blurViewModel::cancelWork, //Added
            modifier = Modifier
                .verticalScroll(rememberScrollState())
                .padding(dimensionResource(R.dimen.padding_medium))
        )
    }
}
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/ui/BluromaticScreen.kt)



<br>

#
### 2.5 Work constraints

#### Adding Battery Not Low Constraint

#### Objective:
- Ensure the `blurWorker` WorkRequest only runs when the device's battery is not low by adding a battery constraint to the WorkManager.


#### Steps to Create the Battery Not Low Constraint:

1. **File:** Open `data/WorkManagerBluromaticRepository.kt`.

2. **Navigate to `applyBlur()` Method:**
    - Locate the `applyBlur()` method.

3. **Create Constraints Variable:**
    - After declaring the `continuation` variable, create a new variable called `constraints`.
    - This variable holds a `Constraints` object for the battery constraint.

4. **Build Constraints Object:**
    - Use the `Constraints.Builder()` function to create the builder for the `Constraints` object.
    - Chain the `setRequiresBatteryNotLow(true)` method to specify that the work should only run when the device's battery is not low.
    - Complete the build process by chaining a call to `.build()`.

5. **Assign Constraints to `blurBuilder`:**
    - Chain the `setConstraints()` method to the `blurBuilder` work request and pass in the `constraints` object to enforce the battery requirement.


#### Example (Explanation):

- **Purpose:** This ensures that the `blurWorker` WorkRequest will be deferred and only run when the device’s battery charge is not low.

#### Note: 
Another good constraint to add to Blur-O-Matic is a [setRequiresStorageNotLow()](https://developer.android.com/reference/androidx/work/Constraints.Builder.html#setRequiresStorageNotLow(kotlin.Boolean)) constraint when saving. To see a full list of constraint options, check out the [Constraints.Builder](https://developer.android.com/reference/androidx/work/Constraints.Builder.html) reference.

```kotlin
// ...
override fun applyBlur(blurLevel: Int) {

// Add this code}
    val constraints = Constraints.Builder()
        .setRequiresBatteryNotLow(true)
        .build()

    blurBuilder.setInputData(createInputDataForWorkRequest(blurLevel, imageUri))
    blurBuilder.setConstraints(constraints) // Add this code
// ...
```
[ View Full Code --> ](./app/src/main/java/dizzcode/com/bluromatic/data/WorkManagerBluromaticRepository.kt)





<br>

#
<kbd>[&nbsp; ► &nbsp;  BACK TO Project Notes  &nbsp;&nbsp;&nbsp;](#ᴠɪ--ᴘʀᴏᴊᴇᴄᴛ-ɴᴏᴛᴇꜱ) </kbd>
____

<br>

<br>

<br>


## 3. Write tests for Worker implementations

### 3.1 Setting Up Dependencies for Testing Workers with WorkManager

#### Background:
- Testing WorkManager workers requires **UI tests** because `Worker` operations depend on Android `Context`, which is unavailable in local unit tests.
- The test will focus on business logic, but since `Context` is required, we use **UI testing frameworks** like JUnit and Espresso.
- Additionally, you need the WorkManager testing API for efficient worker testing.


#### Steps to Set Up Dependencies:

1. **File:** Open `app/build.gradle.kts`.

```kotlin
dependencies {
    // Espresso
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    // Junit
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    // Work testing
    androidTestImplementation("androidx.work:work-testing:2.8.1")
}
```

#### Creating `WorkerInstrumentationTest` for `CleanupWorker`

#### Setup:
- **Directory:** Create a test class in `app/src/androidTest/java/`.
- **Class Name:** Create a new Kotlin class named `WorkerInstrumentationTest`.

<br>

#

### 3.2 Steps to Write the `CleanupWorker` Test:

1. **Create the Test Class:**
    - Create a new Kotlin class called `WorkerInstrumentationTest` in the `androidTest/java` directory.

2. **Create Lateinit Variable:**
    - Inside the class, declare a `lateinit` variable to hold the `Context` instance.

3. **Setup Method:**
    - Create a `setUp()` method annotated with `@Before` to initialize the context.

4. **Write Test Function:**
    - Write a test function called `cleanupWorker_doWork_resultSuccess()` that tests the `CleanupWorker`.

5. **Test Worker Creation:**
    - Use `TestListenableWorkerBuilder` to create an instance of `CleanupWorker` for testing, as it handles coroutine-based worker logic.

6. **Run the Worker:**
    - Use `runBlocking` to execute the `doWork()` function directly, as `CleanupWorker` is a `CoroutineWorker`.
    - Call `doWork()` inside the `runBlocking` lambda.

7. **Result Assertion:**
    - Assert that the result of the worker’s `doWork()` is `ListenableWorker.Result.success()`.

### Example (Code Explanation):
- **Objective:** Verifies that the `CleanupWorker` executes successfully, simulating its behavior without actually queuing the work.
- **Use of `runBlocking`:** Ensures the coroutine worker executes synchronously for the test.
- **Assertion:** Confirms that the worker completes without errors and returns `Result.success()`.



```kotlin
// ...
class WorkerInstrumentationTest {
    private lateinit var context: Context

    @Before
    fun setUp() {
        context = ApplicationProvider.getApplicationContext()
    }

    @Test
    fun cleanupWorker_doWork_resultSuccess() {
        val worker = TestListenableWorkerBuilder<CleanupWorker>(context).build()
        runBlocking {
            val result = worker.doWork()
            assertTrue(result is ListenableWorker.Result.Success)
        }
    }
}
```
[ View Full Code --> ](./app/src/androidTest/kotlin/WorkerInstrumentationTest.kt)

<br>

#

### 3.3 Write a BlurWorker test

#### Steps to Write the `BlurWorker` Test:

1. **Create Test Function:**
    - Create a new test function called `blurWorker_doWork_resultSuccessReturnsUri()` inside `WorkerInstrumentationTest.kt`.

2. **Mock URI Input:**
    - Create a mock URI input to simulate an image. Use a key-value pair where the key is `KEY_IMAGE_URI` and the value is a sample URI, such as `android.resource://com.example.bluromatic/drawable/android_cupcake`.

3. **Build BlurWorker:**
    - In the test function, build a `BlurWorker` instance using `TestListenableWorkerBuilder`.
    - Pass the mock URI input as work data using `setInputData()`.

4. **Run Worker in Coroutine:**
    - Use `runBlocking` to call the worker's `doWork()` function. This ensures the worker runs synchronously in the test.

5. **Access Output Data:**
    - Retrieve the result of the `doWork()` call.
    - Extract the URI from the output data returned by the worker.

6. **Assertion for Success:**
    - Assert that the worker completed successfully.

7. **Verify Output Data:**
    - Make sure the output data contains the key `KEY_IMAGE_URI`.
    - Assert that the URI in the output data starts with `"file:///data/user/0/com.example.bluromatic/files/blur_filter_outputs/blur-filter-output-"` to ensure that the file path is correct.

8. **Null URI Check:**
    - If the URI is null, ensure that the test returns `false` to handle potential null values properly.


#### Explanation:
- **Purpose:** This test ensures that `BlurWorker` successfully processes an image, returns the correct output data, and creates a valid file URI.
- **Output Verification:** The test checks that the `BlurWorker` produces the correct file URI in the output data and confirms that the worker runs without errors.


```kotlin
// ...
@Test
fun blurWorker_doWork_resultSuccessReturnsUri() {
    val worker = TestListenableWorkerBuilder<BlurWorker>(context)
        .setInputData(workDataOf(mockUriInput))
        .build()
    runBlocking {
        val result = worker.doWork()
        val resultUri = result.outputData.getString(KEY_IMAGE_URI)
        assertTrue(result is ListenableWorker.Result.Success)
        assertTrue(result.outputData.keyValueMap.containsKey(KEY_IMAGE_URI))
        assertTrue(
            resultUri?.startsWith("file:///data/user/0/dizzcode.com.bluromatic/files/blur_filter_outputs/blur-filter-output-")
                ?: false
        )
    }
}
```
[ View Full Code --> ](./app/src/androidTest/kotlin/WorkerInstrumentationTest.kt)

<br>

#

### 3.4 Write a SaveImageToFileWorker test

#### Steps to Write the `SaveImageToFileWorker` Test:

1. **Create Test Function:**
    - Create a new test function called `saveImageToFileWorker_doWork_resultSuccessReturnsUri()` inside `WorkerInstrumentationTest.kt`.

2. **Build SaveImageToFileWorker:**
    - Build an instance of the `SaveImageToFileWorker` using `TestListenableWorkerBuilder`.
    - Pass the input data from the previous `BlurWorker` test, which includes the URI of the blurred image.

3. **Run Worker in Coroutine:**
    - Use `runBlocking` to call the `doWork()` function on the `SaveImageToFileWorker`. This ensures the worker executes synchronously during the test.

4. **Access Output Data:**
    - Retrieve the result of the `doWork()` call.
    - Extract the URI from the output data returned by the worker.

5. **Assertion for Success:**
    - Assert that the worker completed successfully.

6. **Verify Output Data:**
    - Check that the output data contains the key for the saved image's URI.
    - Assert that the URI in the output data starts with `"content://media/external/images/media/"` to confirm that the saved image's URI is correctly formatted.

#### Explanation:
- **Purpose:** This test verifies that `SaveImageToFileWorker` successfully saves a blurred image to disk and returns the correct output data.
- **Output Verification:** The test ensures that the worker produces a valid image URI and operates without errors.



```kotlin
// ...
@Test
fun saveImageToFileWorker_doWork_resultSuccessReturnsUrl() {
    val worker = TestListenableWorkerBuilder<SaveImageToFileWorker>(context)
        .setInputData(workDataOf(mockUriInput))
        .build()
    runBlocking {
        val result = worker.doWork()
        val resultUri = result.outputData.getString(KEY_IMAGE_URI)
        assertTrue(result is ListenableWorker.Result.Success)
        assertTrue(result.outputData.keyValueMap.containsKey(KEY_IMAGE_URI))
        assertTrue(
            resultUri?.startsWith("content://media/external/images/media/")
                ?: false
        )
    }
}
```
[ View Full Code --> ](./app/src/androidTest/kotlin/WorkerInstrumentationTest.kt)

<br>



<br>

#
<kbd>[&nbsp; ► &nbsp;  BACK TO Project Notes  &nbsp;&nbsp;&nbsp;](#ᴠɪ--ᴘʀᴏᴊᴇᴄᴛ-ɴᴏᴛᴇꜱ) </kbd>
____



<br>

<hr>
<div align="center">

<kbd>[&nbsp; ⮝ &nbsp;  BACK TO TOP  &nbsp;&nbsp;&nbsp;](#ɪ----ᴘʀᴏᴊᴇᴄᴛ-ɪɴꜰᴏ) </kbd>
</div>
<hr>
<br>
